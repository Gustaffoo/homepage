---
title: "ciphersack - szyfrowana geniza"
author: d33tah
tags: crypto
layout: post
---

<img src="https://upload.wikimedia.org/wikipedia/commons/8/86/TaggedGeniza.jpg" width="360px" align="left" alt="współczesny pojemnik na kolekcję geniza przy ulicy w Nachlaot w Jerozolimie" title="źródło: Wikipedia, licencja: CC BY-SA 2.0, nazwa pliku: TaggedGeniza.jpg">

Przeczytałem ostatnio ciekawy artykuł w w [najnowszym wydaniu International Journal of Proof-of-Concept or Get The Fuck Out](https://archive.org/details/pocorgtfo20/page/n3/mode/2up) (PoC\|\|GTFO). Autor narzekał w nim, że jeśli wszyscy zaczną szyfrować swoje dyski programami takimi jak [VeraCrypt](https://www.veracrypt.fr/en/Downloads.html), w postapokaliptycznym świecie za tysiące lat archeologowie mogą stracić dostęp do danych z dzisiejszych czasów. Koniec końców, bez listów sprzed setek lat, dzisiejsi historycy straciliby ważne źródła informacji i możliwe, że za kilkaset lat pojawi się taka sama potrzeba. Przypomina mi się gra Talos Principle (polecam), gdzie gracz może przeglądać strzępy wirtualnych bibliotek, zawierających wszystko od losowych wpisów na blogach zwykłych ludzi przez prywatną korespondencję naukowców.

Autor wspomnianego artykułu zaproponował "cyfrowe genizy" jako rozwiązanie problemu inspirowane judaistycznymi genizami, czyli archiwami m.in. na święte księgi, które w przypadku przepełnienia przestrzeni zostają poddawane pochówkowi. Ich cyfrowy odpowiednik ma działać podobnie: wydzielamy sobie nieszyfrowany fragment dysku, po czym wypełniamy go danymi które chcielibyśmy, żeby przetrwały tysiąclecia. Jeżeli chcemy zaoszczędzić przestrzeń, możemy najpierw zapełnić dysk pożądanymi archiwami (fabrycznie dysk zawiera same binarne zera), po czym utworzyć na nim układ partycji, zainstalować system i pozwolić mu stopniowo nadpisywać wolną przestrzeń tym, z czego korzystamy. Ja jednak wymyśliłem inne podejście do problemu. Czy dałoby radę utworzyć "cyfrową genizę", która jest szyfrowana?

Miałem w głowie następujący scenariusz: wyobraźmy sobie, że w jakiejś wspólnej przestrzeni, na przykład w Hakierspejsie, przeznaczamy na projekt dostępny dla wszystkich dysk twardy. Na początek wypełniamy go losowymi danymi, żeby utrudnić analizę zawartości. Następnie dla każdego interesującego nas zbioru danych przyporządkujemy związany z nim plik .torrent. Przykładowo, bierzemy obraz płyty CD z najnowszym systemem Ubuntu oraz plik .torrent umożliwiający jego pobranie. Pliki .torrent zawierają metadane opisujące zawartość związanych z nimi danych - przykładowy obraz płyty CD jest w nich podzielony na części (zwane blokami), z których każda jest oddzielnie hashowana skrótem SHA1. Dzięki temu po pobraniu treści z internetu możliwe jest sprawdzenie, czy pobranie się udało: mając plik .torrent można porównać wynik hashowania z metadanych oraz z pełnych danych. Jeśli oba hashe się zgadzają, dane nie są uszkodzone. Sęk w tym, że transfer niekoniecznie musi zostać dokonany przez sieć BitTorrent - mając oryginalny plik .torrent, treść można porównać także offline, dostając dane z innego źródła, np. z innego dysku twardego.

Mając dane źródłowe oraz plik z metadanymi, możemy przystąpić do zapisu szyfrowanych danych. Zgodnie z duchem PoC\|\|GTFO, napisałem "proof of concept", który pokazuje jak można to zrobić: uruchamiamy skrypt ciphersack.py ([kod źródłowy dostępny tutaj](https://github.com/hakierspejs/ciphersack)), wskazując mu tryb "encode" oraz: plik z danymi, metadanymi oraz docelowy dysk twardy. Program odczyta blok po bloku, zapisując je na dysk w postaci zaszyfrowanej. Kluczem będzie hash szyfrowanego bloku XOR numer bloku, a pozycja bloku na dysku także będzie zależeć od hashu bloku. Z tego powodu dysk po naniesieniu na niego szyfrowanego pliku dalej będzie wyglądać jak pseudolosowe dane - poprawnie zaszyfrowane treści niewiele różnią się od białego szumu. Aby odczytać dane, należy posiadać plik z metadanymi i odwrócić procedurę.

Program powstał wyłącznie w celach edukacyjnych - aby pokazać najprostszy scenariusz odczytu pliku .torrent oraz możliwe zastosowanie szyfru AES w steganografii. Jego funkcjonalność celowo jest okrojona, aby ułatwić zrozumienie kodu źródłowego. Odradzam używanie go do danych prywatnych - nie jestem kryptografem i nie wykluczam, że szyfr da się zaatakować. W przypadku jeżeli ktoś jest zainteresowany dalszym rozwojem narzędzia, proponuję następujące kierunki rozwoju:

* analiza szyfru i próba jego złamania, żeby móc załatać ewentualne dziury,
* dodanie obsługi "bazy danych" z informacją o lokalizacjach zaszyfrowanych blokach,
* dodanie obsługi plików .torrent zawierających więcej niż jeden plik (czyli w zasadzie, większości sieci - aktualne rozwiązanie zadziałałoby tylko jako bardzo wyspecjalizowany przykład),
* zmiana algorytmu liczenia offsetu szyfrowanego bloku na dysku: w przypadku gdy według w.w. "bazy danych" na dysku już znajduje się blok, zapisać jego treść pod inną lokalizacją; aktualnie wraz z przyrostem zapisywanych danych wzrasta prawdopodobieństwo, że bloki nawzajem się nadpiszą

[Skomentuj artykuł na Githubie](https://github.com/hakierspejs/homepage/pull/50)
